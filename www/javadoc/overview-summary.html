<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Sun Sep 24 18:16:20 PDT 2006 -->
<TITLE>
Overview (Wizards API)
</TITLE>

<META NAME="date" CONTENT="2006-09-24">

<LINK REL ="stylesheet" TYPE="text/css" HREF="stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Overview (Wizards API)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Overview</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Use</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html?overview-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="overview-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
Wizards API
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#overview_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Packages</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="20%"><B><A HREF="org/netbeans/api/wizard/package-summary.html">org.netbeans.api.wizard</A></B></TD>
<TD>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="20%"><B><A HREF="org/netbeans/spi/wizard/package-summary.html">org.netbeans.spi.wizard</A></B></TD>
<TD>&nbsp;</TD>
</TR>
</TABLE>

<P>
&nbsp;<A NAME="overview_description"><!-- --></A>
<P>
<h1>Wizards API</h1>
  Wizards enable users to complete multi-step tasks, dividing the UI for that
  into simple steps.  This library replaces NetBeans' Wizards API, incorporating
  lessons learned from that API, and providing a simple interface for 
  creating Wizards with minimum effort.
  
  <h2>Basics</h2>
  A wizard is essentially a sequence of panels.  The sequence of panels may
  be fixed, or may contain <i>branch points</i> - panels where, depending on
  the user's input, the list of next steps may change.  Wizards collect input
  on each panel, and at the final step, they create some object or perform
  some task.  They do not alter their environment in any way until the user
  presses the finish button.
  <p>
  Each step of a Wizard is represented by a unique ID string, and a Wizard is
  a factory for JComponent panels corresponding to those IDs.  Each panel is
  constructed only once.  The method that creates the panels is passed a Map.
  Panels of the wizard typically listen to the GUI components they contain, and
  write data into the Map.  What the keys and values are is up to the wizard
  author.  When the user navigates to a new panel, that panel can check the
  data gathered from previous panels and decide whether the Next and/or 
  Finish buttons should be enabled.  Bidirectional navigation is possible - when
  the user navigates back to a previous step, all settings from now-future
  steps disappear from the settings map.  They will reappear if the user
  navigates forward again.
  <p>
  On finish, the Wizard will create an object or do something that alters the
  external environment, deciding what to do based on the input gathered in the
  map.
  <h2>Using the API</h2>
  <p>
  Mostly to use this API you'll be extending very simple convenience classes
  that do most of the work. Those classes are:
  <ul>
  <li><A HREF="org/netbeans/spi/wizard/WizardPanelProvider.html" title="class in org.netbeans.spi.wizard"><CODE>WizardPanelProvider</CODE></A> - the
    tool for creating simple wizards with a fixed list of steps.  Pass the
    steps and their localized descriptions to the superclass constructor;
    override <code>createPanel()</code> to construct panels for the various
    IDs as they are passed;  override <code>finish()</code> to do whatever the
    wizard does with the data it collects.</li>
  <li><A HREF="org/netbeans/spi/wizard/WizardBranchController.html" title="class in org.netbeans.spi.wizard"><CODE>WizardBranchController</CODE></A> -
    Pass the superclass constructor a WizardPanelProvider that handles the 
    initial steps; if the steps after that point are fixed, override 
    <code>getPanelProviderForStep()</code> to return another WizardPanelProvider
    for the subsequent steps - decide what exactly to return based on the
    user's choices.  If there are more branch points, override 
    <code>getWizardForStep()</code>, and use another WizardBranchController's
    <code>getWizard()</code> method as the return value - in this way you can
    have an indefinite number of branches.
  </li>
  <li><A HREF="org/netbeans/spi/wizard/Wizard.html" title="class in org.netbeans.spi.wizard"><CODE>Wizard</CODE></A> - The overall interface for 
     Wizards.  Typically you will not implement this directly - it is useful
     if you are implementing a custom ui <A HREF="org/netbeans/api/wizard/WizardDisplayer.html" title="class in org.netbeans.api.wizard"><CODE>WizardDisplayer</CODE></A>
     for displaying wizards instead of using the default one</li>
  </ul>
  <p>
  
  <h2>Quick Start</h2>
  For a <i>really quick start</i>, use <code>WizardPage</code> as described in
  the <a href="</font>">FAQ</a>.
  <p>
  The Wizards API contains two convenience classes that handle 98% of all 
  use cases for Wizards, and are very simple to use.  A <code>Wizard</code>
  provides a bunch of panels - UI components - each of which can add 
  data to a <code>Map</code>.  At the end of a <code>Wizard</code> the 
  <code>finish (Map settings)</code> method is called, where the wizard
  can create or do what it needs to do.  If the user goes backward, pressing
  the <i>Previous</i> button in a wizard, settings they entered in the 
  &quot;future&quot; are automatically removed (but preserved in case they
  follow the same path again).
  <p>
  Displaying a <code>Wizard</code> once you have one is very simple - call
  <code>WizardDisplayer.show (myWizard)</code>.
  <p>
  <h3>Case 1 - A Simple Wizard with No Branching</h3>
  This is used in the case that all the steps of a wizard are known ahead of
  time.
  The class WizardPanelProvider makes it easy to create a series of panels,
  each of which can add contents to the settings map.  Here is a super-simple
  example, involving two panels, each with a checkbox.  If the first is 
  checked, the Next button is enabled user can move forward.  If the checkbox
  on the second panel is checked and the user can finish the <code>Wizard</code>.
  To display this wizard to a user, you would simply call
  <pre>
  WizardDisplayer.show (new FoodPanelProvider().createWizard());
  </pre>
  Apologies to vegetarians everywhere:
  <pre>
  class FoodPanelProvider extends WizardPanelProvider implements ActionListener {
    private JCheckBox meatBox;
    private JCheckBox steakBox;
    private Map settings;
    private WizardController controller;

    public FoodPanelProvider() {
        super ("Choose Your Dinner", 
            <font color="gray">//below are unique IDs for steps in this Wizard</font>
            new String[] { "vegetarian", "mealChoice" }, 
            <font color="gray">//Should really be localized - human-readable descriptions for the steps</font>
            new String[] { "Food preferences", "Meal Choice" });
    }

    protected JComponent createPanel(WizardController controller, String id, Map settings) {
        this.settings = settings;
        this.controller = controller;
        <font color="gray">//Create a JPanel we'll embed components in</font>
        JPanel result = new JPanel();
        result.setLayout (new FlowLayout());

        if ("vegetarian".equals(id)) { <font color="gray">//We're on the first pane</font>
            meatBox = new JCheckBox("I agree to eat meat");
            meatBox.setSelected (Boolean.TRUE.equals (settings.get("likesMeat")));
            meatBox.addActionListener (this);
            result.add (meatBox);
            controller.setProblem (meatBox.isSelected() ? null : "You must eat meat");
            <font color="gray">//Not the last pane, so the Finish button should never be enabled here</font>
            controller.setCanFinish (false);
        } else if ("mealChoice".equals(id)) {
            steakBox = new JCheckBox ("I will have the steak");
            steakBox.addActionListener (this);
            steakBox.setSelected (Boolean.TRUE.equals (settings.get("eatsSteak")));
            result.add (steakBox);
            controller.setProblem (steakBox.isSelected() ? null : "You must order the steak");
            controller.setCanFinish (steakBox.isSelected());
        } else {
            throw new Error ("Unknown ID " + id);
        }
        return result;
    }

    protected Object finish(Map settings) throws WizardException {
        <font color="gray">//Really you would construct some object or do something with the
        //contents of the map</font>
        return "Food Finished";
    }

    public void actionPerformed (ActionEvent ae) {
        JCheckBox src = (JCheckBox) ae.getSource();
        if (src == meatBox) {
            settings.put ("likesMeat", src.isSelected() ? Boolean.TRUE : Boolean.FALSE);
            controller.setProblem (src.isSelected() ? null : "You must eat meat!");
        } else {
            controller.setCanFinish (src.isSelected());
            settings.put ("eatsSteak", src.isSelected() ? Boolean.TRUE : Boolean.FALSE);
            controller.setProblem (src.isSelected() ? null : "We only serve steak!");
        }
    }
}
  </pre>
  <p>
  <h3>Case 2 - A Wizard With Branches</h3>
  This is used when the set of later steps in a wizard will be totally different
  depending on an earlier choice.  Rather than implement <code>Wizard</code>
  directly, you can implement <code>WizardBranchController</code> and simply 
  call its <code>createWizard()</code> to display it.  A <code>WizardBranchController</code>
  nests sub-wizards inside a parent wizard - it will can create a different sub-wizard
  for later steps depending on the choices in earlier ones.
  <p>
  We'll reuse the vegetarian-friendly class above in this example.  First we have
  an implementation of <code>WizardBranchController</code>.  Its constructor takes
  an argument of <code>WizardPanelProvider</code>.  When that provider runs 
  out of panels, it will look for the next sub-wizard that will provide the
  rest of the steps in the wizard.  Our branch controller will look at the
  contents of the settings map to decide which of two wizards should be the
  continuation of this one.
  <p>
  To actually display this wizard, all you do is call
  <pre>
  WizardDisplayer.show (new BranchControllerImpl().createWizard());
  </pre>
  <p>
  <pre>
    
    private static final String KEY_BRANCH = "colorOrFood";
    private static final String VALUE_FOOD = "food";
    private static final String VALUE_COLOR = "color";
    class BranchControllerImpl extends WizardBranchController {
        
        BranchControllerImpl() {
            super(new Base());
        }
        
        private FoodPanelProvider foodInfo = null;
        private FoodPanelProvider getFoodPanels() {
            if (foodInfo == null) {
                foodInfo = new FoodPanelProvider();
            }
            return foodInfo;
        }
        
        private ColorPanelProvider colorInfo = null;
        private ColorPanelProvider getColorPanels() {
            if (colorInfo == null) {
                colorInfo = new ColorPanelProvider();
            }
            return colorInfo;
        }
        

        protected WizardPanelProvider getPanelProviderForStep (String step, Map settings) {
            String which = (String) settings.get (KEY_BRANCH);
            if (which == null) {
                return null;
            } else if (VALUE_FOOD.equals(which)) {
                return getFoodPanels();
            } else if (VALUE_COLOR.equals(which)) {
                return getColorPanels();
            } else {
                throw new IllegalArgumentException (which);
            }
        }
    }
    
    private static class Base extends WizardPanelProvider implements ActionListener {
        JRadioButton food;
        JRadioButton colors;
        JRadioButton neither;
        Map settings;
        WizardController controller;
        
        public Base () {
            super ("The Look or Eat Wizard", new String[] { "choose" }, new String[] { "Choose to Eat or Look" });
        }
        
        protected JComponent createPanel(WizardController controller, String id, Map settings) {
            this.controller = controller;
            JPanel result = new JPanel();
            result.setLayout (new FlowLayout());
            food = new JRadioButton ("Food");
            colors = new JRadioButton ("Colors");
            neither = new JRadioButton ("Neither");
            result.add (food);
            result.add (colors);
            result.add (neither);
            food.addActionListener(this);
            colors.addActionListener (this);
            neither.addActionListener (this);
            this.settings = settings;
            return result;
        }

        protected Object finish(Map settings) throws WizardException {
            throw new Error ("Finish should never be called for base");
        }
        
        public void actionPerformed (ActionEvent ae) {
            if (ae.getSource() == food) {
                colors.setSelected(false);
                neither.setSelected(false);
                settings.put (KEY_BRANCH, VALUE_FOOD);
                controller.setProblem (null);
            } else if (ae.getSource() == colors) {
                food.setSelected(false);
                neither.setSelected(false);
                settings.put (KEY_BRANCH, VALUE_COLOR);
                controller.setProblem (null);
            } else {
                settings.remove (KEY_BRANCH);
                food.setSelected (false);
                colors.setSelected (false);
                controller.setProblem ("Unacceptable!  You must decide!");
            }
            controller.setCanFinish(ae.getSource() != neither);
        }
    }    
  </pre>
  
  
  <h2>Design Philosophy</h2>
  This library is designed to make it as simple as possible to quickly create
  Wizards.  The following were guiding principles:
  
  <ul>
  <li>A Wizard shall not, under any circumstances, alter its environment
    until the user presses the Finish button</li>
  <li>A Wizard gathers ad-hoc settings from the user.  We will use the 
    simplest reasonable construct for this - a <code>java.util.Map</code>,
    which each pane of a wizard can populate with additional settings;
    each pane can see the settings of past (but not future, if the back
    button has been invoked) panes to decide if the Next or Finish buttons
    should be enabled.
  <li>The order of panes may be ad-hoc in some wizards;  each step of a 
    wizard shall be identified by a unique ID string, which is what will
    be used to tell the wizard what step it's on</li>
  <li>The actual GUI implementation of Wizards must be replaceable, so 
    applications can tune the appearance as they wish</li>
  <li>Most use cases for Wizards are quite simple, so we will do the maximum
   to make it possible to handle common cases with a minimum of code.</li>
  </ul>
  
  A Wizard is a series of steps.  Each step has a String ID.  The user of the
  API provides a factory for panels (UI components) which map to those IDs,
  and provides a localized name and descriptions for the steps.
<P>

<P>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Overview</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Use</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html?overview-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="overview-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
